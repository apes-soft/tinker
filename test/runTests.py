#!/usr/bin/env python
########################################################################
# Test harness to run any of the set of tests supplied with
# Tinker. This uses the files supplied with program output
# as the "correct" answer, running tinker and comparing the
# generated output using a `diff` call to a given tolerance
# to see if they are the same (pass) or not (fail).
# 
# This code was built for the APES project () and is
# distributed under a BSD Licence (see below for the URL).
#
# The aim here is to use python modules that come along with
# the standard distribution of python without requiring any
# additional modules so that it should work out the box. It
# has been tested with python 2.7.
#
# Copyright (c) 2013-2015, The University of Edinburgh.
#
# The original code for the cmp_files, approxEquality and
# approximateDiff functions, which been fairly
# significantly changed, come from a pyclaw (hyperbolic PDE
# solver) regression test code (regression_test.py)
# available at:
#
# http://tinyurl.com/nvsusqu
#
# Clawpack is distributed under the terms of the 
# Berkeley Software Distribution (BSD) license
#
#  http://www.opensource.org/licenses/bsd-license.php
#
# It is:
#
# Copyright (c) 1994--2010, Randall J. LeVeque and others
# All rights reserved.
#
# The function parseType is based on the ParseStrRE lambda function from 
# the stackoverflow thread in:
#
# http://stackoverflow.com/questions/379906/parse-string-to-float-or-int
#
# and was written by krzym. Stackoverflow code is covered
# by a CC-BY-SA licence.
########################################################################

import unittest     # Unit tests
import subprocess   # Call out to subprocesses
import time         # Timing functions
import os           # Get a number of OS routines


# Log output generated by this script to this file:
logfile = "test.log"

# Tolerance to which floating point numbers should be set to equal.
floattolerance = 0.001

# Extension used to run the code
runextension = ".run"

# Extension for output generated by the code run by this script.
outextension = ".out"

# Extension for the reference output to compare against.
refextension = ".log"

################################
# RunSystem: run the test script
################################

def RunSystem(name):

    """
    RunSystem(name): 
    Runs a test script with basename `name` and a `runextension` 
    appended to it. The output produced is directed to 
    an output file `name.out`.
    """

    subprocess.call( "./"+name+runextension,stdout=open(name+refextension,"w"),shell=True)

#########################################################
# CompareFiles: compare a reference output file (with a
# .log extension) with the output generated from a run of
# the shell script. Do a straightforward direct comparison
# and if these are found to be different inspect the internals
# of the file using built in code to compare floating point values
# to a given tolerance.
#########################################################

def CompareFiles(name):

    """
     CompareFiles(name):
     Compare output generated by the program and a canonical
     `refextension` file. The two files compared will thus be
     `name`+outextension and `name`+refextension.
     Floating point values are compared to within a given tolerance.
    """

    return cmp_files(name+outextension,name+refextension)


###########################################################
# cmp_files: compares two files to see if they are the
# same. Returns True if they are the same, False
# otherwise. 
###########################################################
def cmp_files(file1, file2):

    """
    cmp_files(file1, file2):
    Compare differences between file1 and file2. Any differences 
    are written to a logfile.
    """

    import filecmp # File comparison
        
    # Start by using the native python file comparison.
    same = filecmp.cmp(file1, file2)

    # Open an output file for logging.
    fh = open(logfile,"a")

    # If files are the same then the job is done, can return.    
    if (same):
        fh.write("%s\nSuccess - no difference in the outputs.\n%s\n" %\
                 ("="*46,"="*46))
        fh.close()
        return(True)
       
    # Set the floating point tolerance.
    tol = float(floattolerance)
 
    # Find out if there are any differences
    AnyDiff,DiffOut,MaxDiff,MaxLine = approximateDiff(file1,file2,tol)

    # Print to logfile (comment out if too much information).

    delimiter = "="*15
    if(MaxDiff < tol):
       fh.write("%s\n"%(delimiter*5))
       fh.write("Success:- %s and %s the same to within tolerance (%.2f).\n"\
                % (file1,file2,tol))
       fh.write("Maximum difference = %f on line %d.\n"\
                % (MaxDiff,MaxLine))
       fh.write("%s\n"%(delimiter*5))
    else:
       fh.write("%s Start of %s and %s differences %s\n"\
                % (delimiter,file1,file2,delimiter))
       fh.write("%s and %s : Maximum difference = %f on line %s.\n" \
                % (file1,file2,MaxDiff,MaxLine))
       fh.write('%s' % '\n'.join(map(str, DiffOut)))
       fh.write("\n%s End of %s and %s differences %s\n"\
                % (delimiter,file1,file2,delimiter))
    fh.close()

    # Override differences if MaxDiff is within tolerance
    #if(abs(MaxDff) < tolerance):
    #   AnyDiff = True

    # Return True if the differences are within tolerance.    
    return(not AnyDiff)

##########################################################
# parseType: parse a string and return a typed token.  
###########################################################

import re                          # Regular expression functions
from string import maketrans       # String subroutines (maketrans)

def parseType(x):

    """
    parseType(string): 
    Parse an input `string` and return a typed token.
    """

    if(x.isalpha()):      # We have a character
       return str(x)
    elif(x.isdigit()):    # We have an integer
       return int(x)
    elif(re.match('(?i)^-?(\d+\.?\d*[de]-?\+?\d+|\d+\.\d*|0?\.\d+)$', x)): # We have a float
       return float(x.translate(maketrans("Dd","Ee")))
    else:                 # Not sure - return whatever it is.
       return(x)

####################################################################  
# approxEquality: Test for approximate equality for two variables.  If
# both tokens are floats then the test is done to within a given
# tolerance. Returns True if the two tokens are the same or within a
# tolerance for floats. 
####################################################################  

def approxEquality(x,y,epsilon):

    """
    approxEquality(x,y,epsilon):
    Check if x and y are are equal within a tolerance of epsilon or
    not. Floats are treated as special as they may be equal within a
    given tolerance. Returns True if elements are equal or if floats are
    equal within epsilon. The two typed variables are also returned.
    """

    # Remove any spurious characters - tokenization uses
    # spaces so some characters may slip through with
    # numbers, e.g. brackets. 
    m = x.translate(None,")")
    n = y.translate(None,")")

    # Parse the tokens to typed variables.
    a = parseType(m)
    b = parseType(n)

    # Check if the two tokens are the same.
    if(a==b):
       return True

    # If not equal check if they are floats and if so that
    # they are within a given tolerance.
    if(type(a) == float and type(b) == float):
      if(abs(a - b) < epsilon):
         return True
    else:
       # Items are not equal.
       return False


##########################################################
# approximateDiff: calculates the difference between two
# files element by element. Floating point values are 
# treated 
###########################################################
 
def approximateDiff(file1, file2, tol):

    """
    approximateDiff(file1, file2, tol):
    Does an element by element comparison between file and file2. It
    returns True if there are differences or for floating point numbers
    the  differences is larger than the tolerance (tol). 
    Returns True for differences, a list of the differences, the maximum 
    difference and the line number where this occurs.
    """

    fp1      = open(file1, 'r')   # Open input file1.
    fp2      = open(file2, 'r')   # Open input file2.
    lines1   = fp1.readlines()    # Read contents of file1.
    lines2   = fp2.readlines()    # Read contents of file2
    AnyDiff  = False              # Set default (no differences).
    MaxDiff  = 0.0                # Initiate the max difference.
    MaxLine  = 0                  # Initiate the max difference line.
    
    Diff = []                     # Truncate the output buffer
  
    #==== Check file lengths first ====
    #--------------------------------------------------------------------
    # A problem here will indicate that something is structurally different.
    #--------------------------------------------------------------------
    if not(len(lines1) == len(lines2)):
        Diff.append("Output files are of different length.\n")
        AnyDiff = True

    #==== Check line by line ====
    #----------------------------------------------------------------------
    # This is where numerical differences will be highlighted.  Also, if
    # the files are comparable up to a certain point, this will show where
    # they begin to diverge.
    #----------------------------------------------------------------------
    for i in range(min(len(lines1), len(lines2))):

        # Split line into tokens.
        split1 = lines1[i].split();
        split2 = lines2[i].split();
  
        if len(split1) == len(split2):
            #-----------------------------------------------------------
            # If lines have the same number of elements, then check for
            # numerical differences.
            #-----------------------------------------------------------
            for j in range(len(split1)):
 
               # Check if we have differences between two elements.
                AreEqual = approxEquality(split1[j],split2[j],tol)

                # Remove any brackets that slipped through.
                a = parseType(split1[j].translate(None,")"))
                b = parseType(split2[j].translate(None,")"))

                # Check if we have two float types,
                if(type(a) == float and type(b) == float):
                      diff = abs(a-b)
                      if(diff > MaxDiff):   # Difference bigger than permitted tolerance.
                         MaxDiff = diff     # New max difference.
                         MaxLine = i+1      # Store the line where this occurs.

                # For elements that are not the same.
                if (not(AreEqual)):
                    AnyDiff = True # Note that we have a difference.

                    # Store the MaxDifference and the line it is found in
                    if(type(a) == float and type(b) == float):
                      Diff.append("Line "+str(i+1)+", element "+str(j+1)+\
                      " differs "+file1+": "+str(a)+"  " +file2+": "+\
                      str(b)+" diff="+str(diff)+" (Tol="+str(tol)+")")
                    else: # Log differences for non-floats
                      if (type(a) != type(b)):
                         # Output types if the types have not been
                         # parsed correctly.
                         Diff.append("Line "+str(i+1)+", element "+str(j+1)+\
                         " differs in "+file1+": "+str(a)+" ("+str(type(a))+\
                         ")  from " +file2+": "+str(b)+" ("+str(type(b))+")")
                      else:
                         Diff.append("Line "+str(i+1)+", element "+str(j+1)+\
                         " differs in "+file1+": "+str(a)+" from " +file2+\
                         ": "+str(b))
        else:
            #-----------------------------------------------------------
            # If lines have a different number of elements, then print
            # their contents.
            #-----------------------------------------------------------
            AntDiff = True
            Diff.append("Line " + str(i+1) + ", number of elements differs:\n")
            Diff.append("  " + file1 + ": " + lines1[i])
            Diff.append("  " + file2 + ": " + lines2[i])

    return AnyDiff, Diff, MaxDiff, MaxLine

############################################################################
# Tinker test cases.                                                       #
#                                                                          #
# Can run individual tests on the command line by using:                   #
#                                                                          #
#                                ./runTest.py Tinker.testAnion             #
#                                                                          #
############################################################################


class Tinker(unittest.TestCase):
    """

    A Python test harness to run TINKER test
    cases as unit tests.

    """

    # Run before every test.
    def setUp(self):
        fh = open(logfile,"a")                 # Output file to log to.
        self.startTime = time.time()           # Start a timer.
        fh.write("Test %s.\n" % (self.id()))   # Log the test we are running.
        fh.close()                             # Close the output file.

    # Run after every test.
    def tearDown(self):
        fh = open(logfile,"a")                 # Open the output logfile.
        t  = time.time() - self.startTime      # Find out how much time the test took.
        fh.write("Time to run test: %.3f seconds.\n" % (t)) # Log to file.
        fh.close()                             # Close the output file.

    ###############
    # Begin Tests #
    ###############

    def testAnion(self):
        outStem ="anion"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testArgon(self):
        outStem = "argon"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testCluster(self):
        outStem = "cluster"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testCramblin(self):
        outStem = "crambin"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testCyclohex(self):
        outStem = "cyclohex"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testDhfr(self):
        outStem = "dhfr"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testDialanine(self):
        outStem = "dialanine"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testEnkephalin(self):
        outStem = "enkephalin"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testEthanol(self):
        outStem = "ethanol"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testFormaide(self):
        outStem = "formamide"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    # This one takes a long time.
    def testGpcr(self):
        outStem = "gpcr"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testHelix(self):
        outStem = "helix"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    ##########################################
    # Test in the 0README but not in the files.
    #
    # def testIce(self):
    #     outStem = "ice"
    #     RunSystem(outStem)
    #     self.assertTrue(CompareFiles(outStem))

    def testIfabp(self):
        outStem = "ifabp"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testSalt(self):
        outStem = "salt"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testTetraala(self):
        outStem = "tetraala"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))

    def testWater(self):
        skipTest("This is giving a segmentation fault.")
        outStem = "water"
        RunSystem(outStem)
        self.assertTrue(CompareFiles(outStem))


# This bit of code allows the tests to be run from the
# command line. The main function uses the
# unittest.TestLoader class to automatically find and load
# test cases within the current module.

if __name__ == '__main__':

     # Check if logfile already exists
     # If it does rename to be appended by the current time.
     if(os.path.exists(logfile)):
        bkupname = logfile+"_"+time.strftime("%H-%M-%S")
        print "Warning: logfile already exists moving existing logfile to \""\
              +bkupname+"\"."
        os.rename(logfile,bkupname)
 
    # Prompt where some of the output has been put
     print "Detailed output being logged to \""+logfile+"\".\n"
     
     # Run the unit tests  
     unittest.main()

 


